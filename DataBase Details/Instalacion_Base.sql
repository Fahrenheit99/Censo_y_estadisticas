-- Modelo de Base de Datos

-- Create schemas

-- Create tables
CREATE TABLE IF NOT EXISTS tipo_pregunta
(
    id_tipo_pregunta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    nombre_tipo VARCHAR(40),
    PRIMARY KEY(id_tipo_pregunta)
);

CREATE TABLE IF NOT EXISTS pregunta
(
    id_pregunta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_tipo_pregunta INTEGER,
    nombre_pregunta VARCHAR(220),
    PRIMARY KEY(id_pregunta)
);

CREATE TABLE IF NOT EXISTS pregunta_cerrada_multiple
(
    id_respuesta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_pregunta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_formulario INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    PRIMARY KEY(id_respuesta, id_pregunta, id_formulario)
);

CREATE TABLE IF NOT EXISTS pregunta_abierta
(
    id_pregunta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_formulario INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    descripcion_respuesta VARCHAR(60),
    PRIMARY KEY(id_pregunta, id_formulario,descripcion_respuesta)
);

CREATE TABLE IF NOT EXISTS respuesta
(
    id_respuesta INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_pregunta INTEGER,
    descripcion_respuesta VARCHAR(150),
    PRIMARY KEY(id_respuesta)
);

CREATE TABLE IF NOT EXISTS formulario
(
    id_formulario INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    ip_formulario VARCHAR(17),
    id_distrito INTEGER,
    PRIMARY KEY(id_formulario)
);

CREATE TABLE IF NOT EXISTS distrito
(
    id_distrito INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_canton INTEGER,
    nombre VARCHAR(55),
    cant_habitantes INTEGER,
    PRIMARY KEY(id_distrito)
);

CREATE TABLE IF NOT EXISTS canton
(
    id_canton INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    id_provincia INTEGER,
    nombre VARCHAR(55),
    cant_habitantes INTEGER,
    PRIMARY KEY(id_canton)
);

CREATE TABLE IF NOT EXISTS provincia
(
    id_provincia INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    nombre VARCHAR(55),
    PRIMARY KEY(id_provincia)
);


-- Create FKs
ALTER TABLE pregunta
    ADD    FOREIGN KEY (id_tipo_pregunta)
    REFERENCES tipo_pregunta(id_tipo_pregunta)
    MATCH SIMPLE
;
    
ALTER TABLE pregunta_abierta
    ADD    FOREIGN KEY (id_pregunta)
    REFERENCES pregunta(id_pregunta)
    MATCH SIMPLE
;
    
ALTER TABLE pregunta_cerrada_multiple
    ADD    FOREIGN KEY (id_pregunta)
    REFERENCES pregunta(id_pregunta)
    MATCH SIMPLE
;
    
ALTER TABLE pregunta_cerrada_multiple
    ADD    FOREIGN KEY (id_respuesta)
    REFERENCES respuesta(id_respuesta)
    MATCH SIMPLE
;
    
ALTER TABLE formulario
    ADD    FOREIGN KEY (id_distrito)
    REFERENCES distrito(id_distrito)
    MATCH SIMPLE
;
    
ALTER TABLE distrito
    ADD    FOREIGN KEY (id_canton)
    REFERENCES canton(id_canton)
    MATCH SIMPLE
;
    
ALTER TABLE canton
    ADD    FOREIGN KEY (id_provincia)
    REFERENCES provincia(id_provincia)
    MATCH SIMPLE
;
    
ALTER TABLE respuesta
    ADD    FOREIGN KEY (id_pregunta)
    REFERENCES pregunta(id_pregunta)
    MATCH SIMPLE
;
    
ALTER TABLE pregunta_cerrada_multiple
    ADD    FOREIGN KEY (id_formulario)
    REFERENCES formulario(id_formulario)
    MATCH SIMPLE
;
    
ALTER TABLE pregunta_abierta
    ADD    FOREIGN KEY (id_formulario)
    REFERENCES formulario(id_formulario)
    MATCH SIMPLE
;
    

-----------------------------------------------------------------------------------------------

-- Llenado de tablas con archivos en C:


-- Provincias
COPY provincia(id_provincia,nombre) 
FROM 'C:\provincias.csv' DELIMITER ';' CSV HEADER;

SELECT * FROM provincia


-- Cantones
COPY canton(id_canton,id_provincia,nombre,cant_habitantes) 
FROM 'C:\cantones.csv' DELIMITER ';' CSV HEADER;

SELECT * FROM canton


-- Distritos
COPY distrito(id_distrito,id_canton,nombre,cant_habitantes) 
FROM 'C:\distritos.csv' DELIMITER ';' CSV HEADER;

SELECT * FROM distrito

-- Tipos de pregunta
COPY tipo_pregunta(id_tipo_pregunta,nombre_tipo) 
FROM 'C:\tipo_pregunta.csv' DELIMITER ',' CSV HEADER;

SELECT * FROM tipo_pregunta


-- Preguntas
COPY pregunta(id_pregunta,id_tipo_pregunta,nombre_pregunta) 
FROM 'C:\pregunta.csv' DELIMITER ';' CSV HEADER;

SELECT * FROM pregunta


-- Respuestas
COPY respuesta(id_respuesta,id_pregunta,descripcion_respuesta) 
FROM 'C:\respuesta.csv' DELIMITER ';' CSV HEADER;

SELECT * FROM respuesta
------------------------------------------------------------------------------------------------

--Funciones 

CREATE or replace FUNCTION newQuestion(pidNombre integer, pnombre varchar(220)) RETURNS void AS $$
BEGIN
  INSERT INTO pregunta( id_tipo_pregunta ,nombre_pregunta) VALUES (pidNombre,pnombre);
END;
$$ LANGUAGE 'plpgsql';
---------------------------------
CREATE OR REPLACE FUNCTION get_preguntas () 
   RETURNS TABLE (
      id integer,
      tipo integer,
      nombre VARCHAR
) 
AS $$
BEGIN
   RETURN QUERY SELECT * FROM pregunta;
END; 
$$ LANGUAGE 'plpgsql';
---------------------------------

CREATE or replace FUNCTION newQuestionType(pnombre varchar) RETURNS void AS $$
BEGIN
  INSERT INTO tipo_pregunta(nombre_tipo) VALUES (pnombre);
END;
$$ LANGUAGE 'plpgsql';
---------------------------------
CREATE or replace FUNCTION getQuestionType(pidTipo integer) RETURNS 
table (
    nombre varchar
)
AS $$
BEGIN
  return query select nombre_tipo from tipo_pregunta where id_tipo_pregunta = pidTipo;
END;
$$ LANGUAGE 'plpgsql';

--################################

CREATE or replace FUNCTION newFormulario(pipFormulario varchar , pidDistrito integer) 
RETURNS integer AS $$
    Declare
        resultado integer;
BEGIN
  INSERT INTO formulario( ip_formulario ,id_distrito) 
  VALUES (pipFormulario , pidDistrito);
  select currval(pg_get_serial_sequence('formulario', 'id_formulario')) into resultado;
  return resultado;
END;
$$ LANGUAGE 'plpgsql';
--------------------------------
CREATE or replace FUNCTION getProvincias() RETURNS 
table (
    id integer, 
    nombre varchar
)
AS $$
BEGIN
  return query select * from provincia order by id_provincia;
END;
$$ LANGUAGE 'plpgsql';
--################################

CREATE or replace FUNCTION getCanton(pidProvincia integer) RETURNS 
table (
    idCanton integer,
    idProvincia integer,
    nombreCanton varchar
)
AS $$
BEGIN
  return query select id_canton, id_provincia, nombre from canton where id_provincia = COALESCE(pidProvincia, id_provincia);
END;
$$ LANGUAGE 'plpgsql';

--################################

CREATE or replace FUNCTION getDistrito(pidCanton integer) RETURNS 
table (
    idDistrito integer,
    idCanton integer,
    nombreDistrito varchar
)
AS $$
BEGIN
  return query select id_distrito, id_canton, nombre from distrito where id_canton = COALESCE(pidCanton, id_canton);
END;
$$ LANGUAGE 'plpgsql';
---------------------------------

CREATE or replace FUNCTION newAnswer(pidPregunta integer, pDescripcion varchar) RETURNS void AS $$
BEGIN
  INSERT INTO respuesta( id_pregunta, descripcion_respuesta) VALUES (pidPregunta , pDescripcion);
END;
$$ LANGUAGE 'plpgsql';

--################################

CREATE or replace FUNCTION getAnswers(pidPregunta integer) RETURNS 
table (
    idRespuesta integer,
    idPregunta integer,
    descripcion varchar
)
AS $$
BEGIN
  return query select * from respuesta where id_pregunta = COALESCE(pidPregunta, id_pregunta);
END;
$$ LANGUAGE 'plpgsql';


---------------------------------

CREATE or replace FUNCTION newMultipleRaces(listaRazas varchar[]) RETURNS void AS $$
--funcion de prueba que funciona
DECLARE
   number_raza integer := array_length(listaRazas, 1);
   raza_index integer := 1;
BEGIN
   WHILE raza_index <= number_raza LOOP
      INSERT INTO prueba.raza(nombre, ip) VALUES (listaRazas[raza_index], 'nada');
      raza_index = raza_index + 1;
   END LOOP;
END;
$$ LANGUAGE 'plpgsql';
-------------------------------------------------------------
CREATE or replace FUNCTION newOpenAnswer(idPregunta integer,idFormulario integer,listaRespuestas varchar[]) RETURNS void AS $$
--funcion de prueba que funciona
DECLARE
   number_respuestas integer := array_length(listaRespuestas, 1);
   respuestas_index integer := 1;
BEGIN
   WHILE respuestas_index <= number_respuestas LOOP
      INSERT INTO pregunta_abierta(id_pregunta, id_formulario, descripcion_respuesta) 
      VALUES (idPregunta, idFormulario, listaRespuestas[respuestas_index]);
      respuestas_index = respuestas_index + 1;
   END LOOP;
END;
$$ LANGUAGE 'plpgsql';

--################################

CREATE or replace FUNCTION newClose_MultipleAnswer(listaRespuestas integer[],idPregunta integer,idFormulario integer) RETURNS void AS $$
--funcion de prueba que funciona
DECLARE
   number_respuestas integer := array_length(listaRespuestas, 1);
   respuestas_index integer := 1;
BEGIN
   WHILE respuestas_index <= number_respuestas LOOP
      INSERT INTO pregunta_cerrada_multiple(id_respuesta,id_pregunta, id_formulario) 
      VALUES (listaRespuestas[respuestas_index],idPregunta, idFormulario);
      respuestas_index = respuestas_index + 1;
   END LOOP;
END;
$$ LANGUAGE 'plpgsql';

---------------------------------

--Modificaciones JSON 

/*
en este archivo vamos a agregar los espacios de información para las tablas de canton y distrito
*/
ALTER TABLE canton
  ADD json_info jsonb;
 
ALTER TABLE distrito
  ADD json_info jsonb;
  
select * from canton;
select * from distrito;
---------------------------------------------------------------
--SERÍA BUENO CORRER ESTAS FUNCIONES AL ACTUALIZAR LA BASE DE DATOS EN CUANTO A LAS ENFERMEDADES
--FUNCIONES QUE DEFINE EL JSONB DE CADA DISTRITO Y CANTON COMO: {nombre:"texto",poblacion:numero}
--ESTAS FUNCIONES SERÍA BUENO USARLAS AL ACTUALIZAR LA CANTIDAD DE HABITANTES DE UN CANTON O DISTRITO
--FUNCIONES QUE AGREGAN LA SIGUIENTE CARACTERÍSTICAS AL OBJECTO DE DISTRITO Y CANTON: enfermedades registradas en la base de datos
    --estas enfermedades son agregadas con un valor de 0 en caso de no existir y en caso de existir no se modifica el valor
    --CABE MENCIONAR QUE EL ID DE PREGUNTA 4 ESTÁ UN POCO ALAMBRADO PARA TRAER LAS ENFERMEDADES
create or replace function definirJsonParaDistritos()
returns void
as $$
declare
    filaTemporalDistrito record;
    filaTemporalEnfermedad record;
begin
for filaTemporalDistrito/*los distritos*/ in select * from distrito
    loop
        if ( filaTemporalDistrito.json_info is NULL ) then
            update distrito set json_info = 
                ( (select concat('{"nombre":"',filaTemporalDistrito.nombre,'","poblacion":',filaTemporalDistrito.cant_habitantes,'}'))::jsonb )
                where distrito.id_distrito = filaTemporalDistrito.id_distrito;
        end if;
        for filaTemporalEnfermedad/*las enfermedades reportadas*/ in select * from getanswers(4)
            loop
                if (SELECT filaTemporalDistrito.json_info ? filaTemporalEnfermedad.descripcion) then
                
                else
                    UPDATE distrito SET json_info = json_info || 
                    ( select concat('{"',filaTemporalEnfermedad.descripcion,'":',0,'}') )::jsonb
                        where distrito.id_distrito = filaTemporalDistrito.id_distrito;
                end if;
            end loop;
    end loop;
end;
$$ LANGUAGE 'plpgsql';

select definirJsonParaDistritos();
select json_info from distrito;
--reset distrito
--update distrito set json_info = null where id_distrito > 0;
--------------------------------------FUNCIONES PARA LOS CANTONES---------------------------
create or replace function definirJsonParaCantones()
returns void
as $$
declare
    filaTemporalCanton record;
    filaTemporalEnfermedad record;
begin
for filaTemporalCanton/*los distritos*/ in select * from canton
    loop
        if ( filaTemporalCanton.json_info is NULL ) then
            update canton set json_info = 
                ( (select concat('{"nombre":"',filaTemporalCanton.nombre,'","poblacion":',filaTemporalCanton.cant_habitantes,'}'))::jsonb )
                where canton.id_canton = filaTemporalCanton.id_canton;
        end if;
        for filaTemporalEnfermedad/*las enfermedades reportadas*/ in select * from getanswers(4)
            loop
                if (SELECT filaTemporalCanton.json_info ? filaTemporalEnfermedad.descripcion) then
                
                else
                    UPDATE canton SET json_info = json_info || 
                    ( select concat('{"',filaTemporalEnfermedad.descripcion,'":',0,'}') )::jsonb
                        where canton.id_canton = filaTemporalCanton.id_canton;
                end if;
            end loop;
    end loop;
end;
$$ LANGUAGE 'plpgsql';

--reset canton
--update canton set json_info = null where id_canton > 0;
select definirJsonParaCantones();
select json_info from canton;

-----------------------------------------FUNCION PARA MODIFICAR LOS ATRIBUTOS  DEL JSON B----------------------------------
/*
ESTA FUNCIÓN ESTÁ PENSADA PARA USARSE EN EL ENVÍO DEL FORMULARIO A LA BASE DE DATOS, ES DECIR
CUANDO SE INSERTE UN FORMULARIO SE ACTUALIZARÁ EL JSON B
TANTO DEL DISTRITO COMO DEL CANTON, SERÍA BUENO QUE RECIBA UNA LISTA DE ENFERMEDADES
*/

select * from distrito;
--update distrito set json_info = jsonb_set(json_info, '{nombre}', '"Prueba"') where id_distrito = 1;
--select json_info->'poblacion' from distrito where id_distrito = 1;
create or replace function actualizarJsonbConFormulario(id_distritop integer,VARIADIC listaEnfermedades integer[]  )
/*listaEnfermedades varchar[]*/
returns void
as $$
declare
nombreEnfermedad varchar;
nombreConcatenadoDireccion text[];
nombreConcatenadoAtributo varchar;
id_cantonVar integer;
id_enfermedad integer; --
begin
    foreach id_enfermedad in array listaEnfermedades loop
        
        select descripcion_respuesta into nombreEnfermedad from respuesta where id_respuesta = id_enfermedad;
        select concat('{',nombreEnfermedad,'}')::text[] into nombreConcatenadoDireccion;
        select concat('',nombreEnfermedad) into nombreConcatenadoAtributo;
    
        update distrito 
        set json_info = jsonb_set(json_info, nombreConcatenadoDireccion, 
                                  ('' || ((json_info->nombreConcatenadoAtributo)::integer +1))::jsonb )
        where id_distrito = id_distritop;
            
        select id_canton from distrito into id_cantonVar
        where id_distrito = id_distritop;
            
        update canton 
        set json_info = jsonb_set(json_info, nombreConcatenadoDireccion, 
                                  ('' || ((json_info->nombreConcatenadoAtributo)::integer +1))::jsonb ) 
        where id_canton = id_cantonVar;
    
    end loop;
end;
$$ LANGUAGE 'plpgsql';
-----HAY QUE VER SI ESTA FUNCIÓN SE MODIFICA PARA RECIBIR ID DE ENFERMEDADES


--------ACÁ SE VA A HACER UN TRIGGER QUE DISPARE LAS FUNCIONES PARA ACTUALIZAR LOS JSON_INFO DE LAS TRABLAS DE DISTRITO Y CANTON

CREATE OR REPLACE FUNCTION actualizarDistrito_Canton_json_info() RETURNS TRIGGER AS $$  
BEGIN  
 perform definirJsonParaDistritos();
 perform definirJsonParaCantones();
RETURN NEW;   
END;  
$$ LANGUAGE plpgsql;  

CREATE TRIGGER insercionEnEnfermedades AFTER INSERT ON respuesta  
FOR EACH ROW EXECUTE PROCEDURE actualizarDistrito_Canton_json_info();  

--insert into respuesta(id_respuesta, id_pregunta, descripcion_respuesta)
--values(83,4,'otro');
--select * from respuesta
--select * from distrito;
--select * from canton;

--select actualizarJsonbConFormulario(1,83);
--select * from canton;

-- Vistas para gráficos 

--al parecer este dice la cantidad de ocurrencias de una pregunta en las respuestas, e incluye las abiertas como otros
--se arregló solo para que tirara las de las enfermedades autoinmunes como otros
create or replace view respuestas_resgistradas as
select p.id_pregunta as idp ,p.nombre_pregunta as pregunta, r.id_respuesta as idr ,r.descripcion_respuesta as respuesta, ocurrencias 
from 
--empezando consulta anidada
    (select  pcm.id_respuesta as respuesta, count(pcm.id_respuesta) as ocurrencias
    from pregunta_cerrada_multiple as pcm
        group by pcm.id_respuesta
        order by pcm.id_respuesta) as cerradas
--termino de consulta anidada
join respuesta as r 
    on r.id_respuesta = respuesta
join pregunta as p
    on r.id_pregunta = p.id_pregunta--;
union
--consulta para catalogar las preguntas abiertas como "otros"
(select p.id_pregunta, p.nombre_pregunta, 0 ,'Otros' as respuesta,count(pregunta) as otros from
--sub consulta
    (select id_formulario as form, id_pregunta as pregunta
    from pregunta_abierta as pa
    group by id_formulario, id_pregunta
    order by id_pregunta) as preludio_abiertas
--fin de sub consulta 
join pregunta as p
    on p.id_pregunta = pregunta
where p.id_pregunta = 4
group by p.id_pregunta);

--método para acceder a la vista

CREATE OR REPLACE FUNCTION get_respuestas_resgistradas() 
   RETURNS TABLE (
      id_pregunta integer,
      pregunta varchar,
      id_respuesta integer,
      respuesta varchar,
      ocurrencias bigint
) 
AS $$
BEGIN
   RETURN QUERY SELECT * FROM respuestas_resgistradas
   order by idp;
END; 
$$ LANGUAGE 'plpgsql';


select * from get_respuestas_resgistradas() as t;

--conulta para ver las personas que reportaron tener más de 1 enfermedad autoinmune
create or replace view cantidad_de_enfermedades_reportadas as
select apar.id_formulario as formulario, apariciones
from (select id_formulario ,count(*) as apariciones from pregunta_cerrada_multiple as pcm
    where pcm.id_pregunta = 4
    group by id_formulario
    order by id_formulario) as apar;


--método para la consulta de la vista de enfermedades reportadas

CREATE OR REPLACE FUNCTION get_cantidad_de_enfermedades_reportadas() 
   RETURNS TABLE (
       formulario integer,
       apariciones bigint
) 
AS $$
BEGIN
   RETURN QUERY SELECT * FROM cantidad_de_enfermedades_reportadas;
END; 
$$ LANGUAGE 'plpgsql';
----------------------------------------------------------------------
select * from get_cantidad_de_enfermedades_reportadas() as t; 


/*
|----------------------------------------------------------------|
|Formulario --> id distrito --> id canton                        |
|respuestas_cerradas_multiples --> id_respuesta, id_formulario   |
|respuestas --> id respuestas, id pregunta, descripcion          |
|pregunta --> id_pregunta, descripcion                           |
|________________________________________________________________|
sobre esta tabla se pueden aplicar consultas para saber los datos exactos y así poder colocar los filtros
preguntar por cada pregunta,distrito y cantón y hacer un count, hay que ver la manera de descartar la opción de "otros"
y agregarla en la base de datos para poder filtrar mejor
*/

create or replace view respuestas_registradas_x_ubicacion as
select f.id_formulario, pcm.id_pregunta, p.nombre_pregunta as pregunta,
r.id_respuesta, r.descripcion_respuesta as respuesta, d.id_distrito , d.nombre as distrito , c.id_canton, c.nombre as canton
-------------------------------------------------------------------------
from formulario as f 
join distrito as d
    on f.id_distrito = d.id_distrito
join canton as c
    on c.id_canton = d.id_canton
join pregunta_cerrada_multiple as pcm
    on pcm.id_formulario = f.id_formulario
join pregunta as p
    on pcm.id_pregunta = p.id_pregunta
join respuesta as r
    on r.id_respuesta = pcm.id_respuesta;
--order by id_distrito, id_formulario,id_pregunta;
select * from respuestas_registradas_x_ubicacion
order by id_distrito, id_formulario, id_pregunta;--compensar la falta de orden
------------------------FUNCIÓN DE CONSULTA
CREATE OR REPLACE FUNCTION get_respuestas_y_ubicacion() 
   RETURNS TABLE (
       id_formulario integer,
       id_pregunta integer,
       pregunta varchar,
       id_respuesta integer,
       respuesta varchar,
       id_distrito integer,
       distrito varchar,
       id_canton integer,
       canton varchar
) 
AS $$
BEGIN
   RETURN QUERY select * from respuestas_registradas_x_ubicacion
                        order by id_distrito, id_formulario, id_pregunta;--compensar la falta de orden
END; 
$$ LANGUAGE 'plpgsql';
---------------------USAGE-------------------
select * from get_respuestas_y_ubicacion() as t; 
--4 es el # de pregunta que representa la enfermedades
--hay que ver el rango en el que se mueven esas enfermedades 
--hay que ver que formularios tienen anclada esas enfermedades y consultarlos 


/*
consulta para ver las posibles respuestas a la pregunta de las enfermedades --> (no por el asunto del async-await)
crear consulta para saber los formularios asociados a una enfermedad y ver la relación
confeccionar el json
hacer la estructura para actualizar el json
*/

/*VISTA Y MÉTODOS PARA LOS GRÁFICOS Y LAS RELACIONES DE PREGUNTA-ITEM*/

create or replace view respuestas_registradas_resumen as
select f.id_formulario, pcm.id_pregunta, p.nombre_pregunta as pregunta,
r.id_respuesta, r.descripcion_respuesta as respuesta
--esta consulta va a permitir ver la relación entre las enfermedades y los demás items
-------------------------------------------------------------------------
from formulario as f 
join pregunta_cerrada_multiple as pcm
    on pcm.id_formulario = f.id_formulario
join pregunta as p
    on pcm.id_pregunta = p.id_pregunta
join respuesta as r
    on r.id_respuesta = pcm.id_respuesta;
------------------------FUNCIÓN DE CONSULTA
CREATE OR REPLACE FUNCTION get_respuestas_resumen() 
   RETURNS TABLE (
       id_formulario integer,
       id_pregunta integer,
       pregunta varchar,
       id_respuesta integer,
       respuesta varchar
) 
AS $$
BEGIN
   RETURN QUERY select * from respuestas_registradas_resumen
                        order by id_formulario, id_pregunta;--compensar la falta de orden
END; 
$$ LANGUAGE 'plpgsql';
---------------------USAGE-------------------
select * from get_respuestas_resumen() as t; 


--------------------------para obtener formualrios asociados a una respuesta------------------------
create or replace function get_formulariosAsociados(id_respuestap integer) returns 
table(
    id_respuesta integer,
    id_pregunta integer,
    id_formulario integer
)
as $$
begin
    return query select * from pregunta_cerrada_multiple as pcm
    where pcm.id_respuesta = coalesce(id_respuestap, pcm.id_respuesta)
    order by id_formulario;
end;
$$ LANGUAGE 'plpgsql';
------------------usage
select * from get_formulariosAsociados(33) as t;




----------PRUEBA------
select id_formulario, id_pregunta, pregunta, id_respuesta, respuesta
    from respuestas_registradas_resumen
    where id_respuesta != 33 and id_formulario in (select id_formulario from pregunta_cerrada_multiple where id_respuesta=33)
    and id_respuesta in (1,2)
    order by id_formulario, id_pregunta;--compensar la falta de orden
---with count--- AND JOIN-----PRUEBA
select rrr.id_formulario, rrr.id_pregunta, rrr.pregunta, rrr.id_respuesta, rrr.respuesta, counter.conteo from 
(select id_respuesta, count(id_respuesta) as conteo
    from respuestas_registradas_resumen
    where id_respuesta != 33/*este campo es dinámico*/ 
            and id_formulario in 
                                (select id_formulario from pregunta_cerrada_multiple where id_respuesta=33)/*este campo es dinámico*/
    group by id_respuesta) as counter
join respuestas_registradas_resumen as rrr on
counter.id_respuesta = rrr.id_respuesta
order by rrr.id_respuesta;
-------------METODO QUE TRAE LA RELACIÓN DE UNA ENFERMEDAD CON LOS DEMÁS ITEMS-----------------
CREATE OR REPLACE FUNCTION GET_RELATION( VARIADIC list integer[] /*list integer[]*/)
RETURNS TABLE(
    id_pregunta integer,
    pregunta varchar,
    id_respuesta integer,
    respuesta varchar,
    conteo bigint
)
AS $$
BEGIN
RETURN QUERY select p.id_pregunta, p.nombre_pregunta as pregunta, 
r.id_respuesta, r.descripcion_respuesta as respuesta, counter.conteo from 
(select count(rrr.id_respuesta) as conteo, rrr.id_respuesta
    from respuestas_registradas_resumen as rrr
    where rrr.id_respuesta != ANY(list)  
            and rrr.id_formulario in 
                    (select pcm.id_formulario from pregunta_cerrada_multiple as pcm where pcm.id_respuesta = ANY(list))
    group by rrr.id_respuesta) as counter
join respuesta as r on
r.id_respuesta = counter.id_respuesta
join pregunta as p on
r.id_pregunta = p.id_pregunta
order by r.id_respuesta;
END;
$$ LANGUAGE 'plpgsql';

----USAGE-----------
select * from get_relation(32)as t;--12 al parecer no tiene casos registrados
--32 --> 1 MASCULINO
--29 --> 1 FEMENINO
--23 --> 1 MASCULINO
select * from respuesta where id_pregunta = 4;
--9 al 32

select * from getanswers(4);
--###################################3CAMBIO DE LÓGICA AQUÍ)
----CONSULTA PARA OBTENER DATOS NO REPETIDOS


---VARIADIC list NUMERIC[],
